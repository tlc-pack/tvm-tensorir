# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""Search Strategy"""

import random

from typing import List, TYPE_CHECKING

from tvm._ffi import register_object
from tvm.runtime import Object
from tvm.tir.schedule import Trace

from . import _ffi_api

if TYPE_CHECKING:
    from .tune_context import TuneContext


@register_object("meta_schedule.SearchStrategy")
class SearchStrategy(Object):
    """
    Search strategy is the class that generates the measure candidates. The class is mutable and
    can be changed by calling the methods in this class. It has to be pretuned before usage and
    posttuned after usage.

    When the `generate_measure_candidates` method is called, the search strategy will generate
    measure candidates. The measure candidates are generated according to the search strategy.
    The measure candidates are returned as a list of builder input. If the retuened list is empty,
    the search strategy has finished the search.

    When the `notify_runner_results` method is called, the search strategy will notify the
    runner results. The runner results are used to update the search strategy.
    """

    def initialize_with_tune_context(
        self,
        context: "TuneContext",
    ) -> None:
        """Initialize the search strategy with the given tune context.
        Parameters
        ----------
        context : TuneContext
            The tunning context for the space generator, also allowing access to all other classes
            in the same tunning context.
        """
        _ffi_api.SearchStrategyInitializeWithTuneContext(self, context)  # pylint: disable=no-member

    def generate_measure_candidates(self) -> List["BuilderInput"]:
        """Generate measure candidates.

        Returns
        -------
        measure_candidates : List[BuilderInput]
            The generated measure candidates to be sent to the builder.
        """
        return _ffi_api.SearchStrategyGenerateMeasureCandidates(self)  # pylint: disable=no-member

    def notify_runner_results(self, results: List["RunnerResult"]) -> None:
        """Notify the runner results.

        Parameters
        ----------
        results : List[RunnerResult]
            The runner results generated by the runner, to be used to update the search strategy.
        """
        _ffi_api.SearchStrategyNotifyRunnerResults(self, results)  # pylint: disable=no-member

    def pre_tuning(self, design_spaces: List[Trace]) -> None:
        """Initiate the search strategy status before tuning.

        Parameters
        ----------
        design_spaces : List[Trace]
            The design spaces to be used for tuning.
        """
        _ffi_api.SearchStrategyPreTuning(self, design_spaces)  # pylint: disable=no-member

    def post_tuning(self) -> None:
        """Finish the search strategy process after tuning"""
        _ffi_api.SearchStrategyPostTuning(self)  # pylint: disable=no-member


@register_object("meta_schedule.PySearchStrategy")
class PySearchStrategy(SearchStrategy):
    """Search strategy that is implemented in python"""

    def __init__(self):
        """Construct a PySearchStrategy.
        No parameters but uses the function `initialize_with_tune_context` and other functions
        defined in class body.

        Note
        ----
        The PySearchStrategy will use the `initialize_with_tune_context` and other functions
        defined in the class body as the function call.
        """

        def initialize_with_tune_context_func(context: "TuneContext") -> None:
            """Pass the initialize_with_tune_context function to constructor."""
            self.initialize_with_tune_context(context)

        def generate_measure_candidates_func() -> List["BuilderInput"]:
            """Pass the generate_measure_candidates function to constructor."""
            return self.generate_measure_candidates()

        def notify_runner_results_func(results: List["RunnerResult"]) -> None:
            """Pass the notify_runner_results function to constructor."""
            self.notify_runner_results(results)

        def pre_tuning_func(design_spaces: List[Trace]) -> None:
            """Pass the pre_tuning function to constructor."""
            self.pre_tuning(design_spaces)

        def post_tuning_func() -> None:
            """Pass the post_tuning function to constructor."""
            self.post_tuning()

        self.__init_handle_by_constructor__(
            _ffi_api.PySearchStrategy,  # pylint: disable=no-member
            initialize_with_tune_context_func,
            generate_measure_candidates_func,
            notify_runner_results_func,
            pre_tuning_func,
            post_tuning_func,
        )

    def initialize_with_tune_context(self, context: "TuneContext") -> None:
        """Initialize the search strategy with a given context

        Parameters
        ----------
        context : TuneContext
            The auto tuning context
        """
        raise NotImplementedError

    def generate_measure_candidates(self) -> List["BuilderInput"]:
        """generate candidates for autotuning measurement according to the tune context.

        Parameters
        ----------
        context : TuneContext
            The auto tuning context
        """
        raise NotImplementedError

    def notify_runner_results(self, results: List["RunnerResult"]) -> None:
        """Update the search srategy status accoding to the runner's results.

        Returns
        -------
        results: List[Schedule]
            A list of schedules
        """
        raise NotImplementedError

    def pre_tuning(self, design_spaces: List[Trace]) -> None:
        """Initiate the search strategy status before tuning.
        Parameters
        ----------
        design_spaces : List[Trace]
            The design spaces to be used for tuning.
        """
        raise NotImplementedError

    def post_tuning(self) -> None:
        """Finish the search strategy process after tuning."""
        raise NotImplementedError


class ReplaySearchStrategy(PySearchStrategy):
    """
    Replay Search Strategy is a search strategy that always replays the trace by removing its
    decisions so that the decisions would be randomly re-generated.
    """

    def __init__(self, trials, batch_size):
        """
        Construct a ReplaySearchStrategy.
        Parameters
        ----------
        trials : int
            The number of total trials to be replayed.
        batch_size : int
            The batch size of the replayed trials.
        """
        super().__init__()  # use abstract class's __init__ method
        self.trials = trials
        self.batch_size = batch_size

    def initialize_with_tune_context(self, context: "TuneContext") -> None:
        """Initialize the search strategy with the given tune context.
        Parameters
        ----------
        context : TuneContext
            The tunning context for the space generator, also allowing access to all other classes
            in the same tunning context.
        """

    def generate_measure_candidates(self) -> List["BuilderInput"]:
        """Generate measure candidates.

        Returns
        -------
        measure_candidates : List[BuilderInput]
            The generated measure candidates to be sent to the builder.
        """
        if self.count >= self.trials:
            return None
        candidates = []
        for _ in range(self.count, min(self.count + self.batch_size, self.trials)):
            trace = Trace(random.choice(self.design_spaces).insts, None)
            candidates.append(trace)
        return candidates

    def notify_runner_results(self, results: List["RunnerResult"]) -> None:
        """Notify the runner results.

        Parameters
        ----------
        results : List[RunnerResult]
            The runner results generated by the runner, to be used to update the search strategy.
        """
        self.count += len(results)

    def pre_tuning(self, design_spaces: List["Trace"]) -> None:
        """Initiate the search strategy status before tuning.
        Parameters
        ----------
        design_spaces : List[Trace]
            The design spaces to be used for tuning.
        """
        self.design_spaces = design_spaces  # assign the design spaces to the class
        self.count = 0  # reset the count

    def post_tuning(self) -> None:
        """Finish the search strategy process after tuning"""
